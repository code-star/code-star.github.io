<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/4cf2300e9c8272f7-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="/articles/images/1iBVlr8lOKvIzbqA8-qvHoQ.gif"/><link rel="preload" as="image" href="/articles/images/16mEccGy9WNOJ5zU_8a35DA.png"/><link rel="preload" as="image" href="/articles/images/1g_5XkBVLaWIkvs7W_XHv8g.png"/><link rel="preload" as="image" href="/articles/images/1JmOikDAspLJuHPY07W1-Lw.png"/><link rel="stylesheet" href="/_next/static/css/deecf931bfbdc38e.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/13422ae1d848e043.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-bafee5ae243c8c89.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-0d7e8c6ba2452810.js" async=""></script><script src="/_next/static/chunks/main-app-b25855ec5ccc6eda.js" async=""></script><script src="/_next/static/chunks/970-4a0f7daee52c7cff.js" async=""></script><script src="/_next/static/chunks/173-77a4cc13cb7e18d3.js" async=""></script><script src="/_next/static/chunks/app/articles/%5Bslug%5D/layout-0f8ac0524a72511b.js" async=""></script><script src="/_next/static/chunks/app/articles/%5Bslug%5D/page-c42cdda36797932a.js" async=""></script><meta name="next-size-adjust" content=""/><title>Codestar</title><meta name="description" content="Codestar - a Sopra Steria team"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_188709 __variable_9a8899"><nav class="TopBar_top-bar__RDkoF"><div><a href="/"><img alt="Codestar Logo" loading="lazy" width="150" height="40" decoding="async" data-nimg="1" style="color:transparent" src="/codestar_logo_cream-red.svg"/></a><ul><li><a href="https://www.linkedin.com/company/codestar-powered-by-sopra-steria/">Contact</a></li></ul></div></nav><div class="layout_content__K15KO"><main class="layout_main__Afkre"><h1>Leibniz equality in TypeScript</h1><p>Published at <!-- -->2019-04-03<!-- --> by <!-- -->Werner de Groot</p><p>In this post I’ll explain how you can use Leibniz equality to safely type your higher-order components in React, although it can be used in many other places (outside the React ecosystem) too.</p>
<h2>Introduction</h2>
<p>At the client I’m currently working for we use a lot of different charts to visualize processes over time. We have line charts, Gantt charts, you name it. Each of those charts features buttons which allows users to zoom in or out.</p>
<p>I’d like to use a simplified version of one of those graphs to explain what Leibniz, a German mathematician who lived well over 300 years ago, has to do with TypeScript.</p>
<h2>Motivating example</h2>
<p>Let&#x27;s suppose our graph looks a bit like this:</p>
<img src="/articles/images/1iBVlr8lOKvIzbqA8-qvHoQ.gif" alt="" width="494"/>
<p>I use a component <code>Graph</code> which takes the following props:</p>
<p><code>[GraphProps.ts](https://gist.github.com/wernerdegroot-blogs/233ddd104b1e58f14382de69080c7f9f#file-GraphProps-ts)</code></p>
<pre><code>type GraphProps = {
  activities: Activity[]
  dayStart: number
  dayEnd: number
  onZoomIn: () =&gt; void
  onZoomOut: () =&gt; void
}
</code></pre>
<p>What do we need to show a graph? We need:</p>
<ul>
<li><code>activities</code> to show;</li>
<li><code>dayStart</code> and <code>dayEnd</code>, which specify the range of the time axis;</li>
<li><code>onZoomIn</code> and <code>onZoomOut</code> to control the range of the time axis from inside the component.</li>
</ul>
<h2>Zooming in and out</h2>
<p>In this aside, I’d like to show you the function that handles zooming in or out. It’s not really relevant to the rest of the story (and you can skip this if you like) but it might come in handy if you wish to code along with this blog post.</p>
<p><code>[zoom.ts](https://gist.github.com/wernerdegroot-blogs/ba3ebc50d0c63c54bd89d6672b7edaa7#file-zoom-ts)</code></p>
<pre><code>function zoom(dayStart: number, dayEnd: number, zoomFactor: number): [number, number] {
  // What is the middle of the time range?
  // When zooming in or out, the middle of the time range should stay the middle.
  const dayMiddle = (dayEnd + dayStart) / 2
 
  // Determine what the new time range should be using the `zoomFactor`.
  const oldTimeRange = dayEnd - dayStart
  const newTimeRange = oldTimeRange * zoomFactor
 
  // Calculate the new boundaries of the time range:
  const newDayStart = dayMiddle - newTimeRange / 2
  const newDayEnd = dayMiddle + newTimeRange / 2
  
  return [newDayStart, newDayEnd]
}
</code></pre>
<h2>Higher-order component</h2>
<p>Although it is tempting to let this component manage its own <code>dayStart</code> and <code>dayEnd</code> (especially now that we can use hooks), it has two benefits to manage that state externally:</p>
<ul>
<li>I can easily expose the component to different states, which makes it easy to test;</li>
<li>I can change that state from the outside if I need to (for instance to ensure that all visible charts share the same time axis).</li>
</ul>
<p>If I would create a higher-order component (HOC) to manage that state for me, I would get the best of both worlds. I get an easy to use component which manages its own state if I wrap <code>Graph</code> in this HOC, but I get a lot of power if I choose not to.</p>
<p>Furthermore, I can apply this HOC to many other components which have a time axis and support some form of zooming in and out.</p>
<p>What should this HOC look like? What is the input? And what is the output?</p>
<ul>
<li>The component that we pass to the HOC (the “inner component”) should have some props provided automatically by the component that the HOC produces (the “outer component”).</li>
<li>The outer component should forward any other props to the inner component. Those are the only props that we need to provide to the outer component.</li>
<li>TypeScript should be able to infer all of this automatically.</li>
</ul>
<p>The HOC we will write will provide the following props to the inner component (which we’ll call <code>Inner</code> in what follows):</p>
<p><code>[leibniz-03-TimeAxisProps.ts](https://gist.github.com/wernerdegroot-blogs/d2ab9d1b04b4170309dd81b5b85db6c5#file-leibniz-03-TimeAxisProps-ts)</code></p>
<pre><code>type TimeAxisProps = {
  dayStart: number
  dayEnd: number
  onZoomIn: () =&gt; void
  onZoomOut: () =&gt; void
}
</code></pre>
<p>It will produce a component (which we’ll call <code>Outer</code> from now on) that takes the following props¹:</p>
<p><code>[leibniz-04-OuterProps.ts](https://gist.github.com/wernerdegroot-blogs/f8dc13b757ddbba78bcd5d01d14e8c1a#file-leibniz-04-OuterProps-ts)</code></p>
<pre><code>type OuterProps&lt;InnerProps&gt; = Omit&lt;InnerProps, keyof TimeAxisProps&gt;
</code></pre>
<p>This might be a bit intimidating. What this says is that we can determine the props to the outer component (<code>OuterProps</code>) from the props to the inner component (<code>InnerProps</code>) by removing all values that are shared with <code>TimeAxisProps</code> (<code>dayStart</code>, <code>dayEnd</code>, <code>onZoomIn</code> and <code>onZoomOut</code> to be precise)².</p>
<p>Now that we know what the HOC should do, we can focus on <em>how</em> it should do it:</p>
<p><code>[leibniz-05-WithTimeAxis.tsx](https://gist.github.com/wernerdegroot-blogs/5a37a833eed02e85f937572087bd09fc#file-leibniz-05-WithTimeAxis-tsx)</code></p>
<pre><code>// The state that we want to manage for `Inner`:
type OuterState = {
  dayStart: number
  dayEnd: number
}

function WithTimeAxis&lt;InnerProps extends TimeAxisProps&gt;(Inner: React.ComponentType&lt;InnerProps&gt;) {
  return class Outer extends React.Component&lt;OuterProps&lt;InnerProps&gt;, OuterState&gt; {
    constructor(props: OuterProps&lt;InnerProps&gt;) {
      super(props)
      
      // Choose a sensible default state:
      this.state = {
        dayStart: 0,
        dayEnd: 10
      }
    }
    
    public render() {
      // Construct `TimeAxisProps`.
      const timeAxisProps: TimeAxisProps = {
        dayStart: this.state.dayStart,
        dayEnd: this.state.dayEnd,
        onZoomIn: this.handleZoomIn,
        onZoomOut: this.handleZoomOut
      }
      
      // Combine `OuterProps` and `TimeAxisProps` 
      // to get `InnerProps`.
      const innerProps: InnerProps = {
        ...this.props,
        ...timeAxisProps
      }
     
      // Render...
      return &lt;Inner {...innerProps} /&gt;
    }
    
    private handleZoomOut = () =&gt; {
     const [newDayStart, newDayEnd] = zoom(
        this.state.dayStart,
        this.state.dayEnd,
        2 // Make the time range twice as big
      )
      this.setState({ dayStart: newDayStart, dayEnd: newDayEnd })
    }
    
    private handleZoomIn = () =&gt; {
      const [newDayStart, newDayEnd] = zoom(
        this.state.dayStart,
        this.state.dayEnd,
        0.5 // Make the time range half as big (twice as small)
      )
      this.setState({ dayStart: newDayStart, dayEnd: newDayEnd })
    }
  }
}
</code></pre>
<p>That’s a big piece of code! We can see how to handle zooming in and zooming out. We can also see how we can combine both the <code>OuterProps</code> and the <code>TimeAxisProps</code> to render the <code>Inner</code>-component. You might also have noticed that <code>InnerProps extends TimeAxisProps</code>. Constraining our generic type parameter it this way ensures that we can only apply this HOC on components that have at least the props <code>dayStart</code>, <code>dayEnd</code>, <code>onZoomIn</code> and <code>onZoomOut</code> that we’d like to provide to it. If that component doesn’t have these four props, why even apply <code>WithTimeAxis</code>, right?</p>
<h2>Trouble</h2>
<p>There is, however, a tiny problem… It doesn&#x27;t compile!</p>
<img src="/articles/images/16mEccGy9WNOJ5zU_8a35DA.png" alt="" width="800"/>
<p>But why doesn&#x27;t it? TypeScript has trouble figuring out that the combination of <code>OuterProps&lt;InnerProps&gt;</code> and <code>TimeAxisProps</code> is equal to <code>InnerProps</code>. Although this is true for the case with <code>GraphProps</code>, it isn&#x27;t true in general.</p>
<p>To give you an example in which this isn’t true, let’s suppose that we try to apply the HOC to a component <code>CounterExample</code> with the following props:</p>
<p><code>[leibniz-06-CounterExampleProps.ts](https://gist.github.com/wernerdegroot-blogs/17879a042e2df6fbf7be765fb07fc6b8#file-leibniz-06-CounterExampleProps-ts)</code></p>
<pre><code>type CounterExampleProps = {
  activities: Activity[]
  dayStart: 0 // Can only start at zero!
  dayEnd: number
  onZoomIn: () =&gt; void
  onZoomOut: () =&gt; void
}
</code></pre>
<p>where I’d like to point your attention to the <code>dayStart: 0</code>.</p>
<p>I admit, this is a bit farfetched, but it does illustrate the point. We shouldn’t apply <code>WithTimeAxis</code> to <code>CounterExample</code> as the HOC might provide a <code>dayStart</code> that is not equal to zero. In fact, changing the zoom level multiple times ensures that <code>dayStart</code> will eventually be non-zero, even if it was equal to zero initially.</p>
<p>The TypeScript isn’t complaining about this when we do try to apply <code>WithTimeAxis</code> to <code>CounterExample</code>, as <code>CounterExampleProps</code> nicely extends <code>TimeAxisProps</code> as I required. <code>CounterExampleProps</code> is more specific than <code>TimeAxisProps</code> (because the type <code>0</code> is more specific than <code>number</code>) but that is allowed for subtypes. Instead, the compiler has noticed this possibility even before we did, and that is why our HOC doesn’t compile!</p>
<p>The root of our issues is with the <code>InnerProps extends TimeAxisProps</code> constraint. What we try to express is that all properties of <code>TimeAxisProps</code> are shared with <code>InnerProps</code> without allowing for subtypes. Unfortunately <code>extends</code> is currently the best we can do. In fact, it’s the only type of constraint we can express on our generic type parameters in TypeScript.</p>
<h2>Hope on the horizon</h2>
<p>We can solve this problem by pushing the burden of proof up a level. We ask the user for a function <code>convert</code> that is able to convert the combination of <code>OuterProps&lt;InnerProps&gt;</code> and <code>TimeAxisProps</code> (which can be expressed in TypeScript as <code>OuterProps&lt;InnerProps&gt; &amp; TimeAxisProps</code>) to <code>InnerProps</code>. If the user can do that, we can call <code>Inner</code> with the right props:</p>
<p><code>[leibniz-07-WithTimeAxis.tsx](https://gist.github.com/wernerdegroot-blogs/b0ce2eb9479c9d548b4ce3495bb211a5#file-leibniz-07-WithTimeAxis-tsx)</code></p>
<pre><code>function WithTimeAxis&lt;InnerProps extends TimeAxisProps&gt;(
  Inner: React.ComponentType&lt;InnerProps&gt;,
  convert: (p: OuterProps&lt;InnerProps&gt; &amp; TimeAxisProps) =&gt; InnerProps
) {
  return class Outer extends React.Component&lt;OuterProps&lt;InnerProps&gt;, OuterState&gt; {
    
    ...
    
    public render() {
     
      ...
      
      // Combine `OuterProps` and `TimeAxisProps` 
      // to get `InnerProps`.
      const innerProps: InnerProps = convert({
        ...this.props,
        ...timeAxisProps
      })
     
      // Render...
      return &lt;Inner {...innerProps} /&gt;
    }
    
    ...
    
  }
}
</code></pre>
<p>What does this conversion function look like in the example of <code>GraphProps</code>? It’s not very difficult at all! In the example of <code>GraphProps</code> we can see that:</p>
<ul>
<li>The parameter type is <code>Omit&lt;GraphProps, keyof TimeAxisProps&gt; &amp; TimeAxisProps</code>, which the compiler knows is just a fancy way to write <code>GraphProps</code>;</li>
<li>The return type is <code>GraphProps</code>.</li>
</ul>
<p>What it boils down to is that we are asked to provide a function that makes this very trivial conversion:</p>
<p><code>[leibniz-08-trivial.ts](https://gist.github.com/wernerdegroot-blogs/9e53339b4ed8a0485174812ddea9823e#file-leibniz-08-trivial-ts)</code></p>
<pre><code>function trivial(graphProps: GraphProps): GraphProps {
  return graphProps
}

const GraphWithTimeAxis = WithTimeAxis(Graph, trivial)
</code></pre>
<p>We can even use the identity function if we’d like:</p>
<p><code>[leibniz-09-identity.ts](https://gist.github.com/wernerdegroot-blogs/0c0d992f20045903fc0e50233d7f64dc#file-leibniz-09-identity-ts)</code></p>
<pre><code>function identity&lt;T&gt;(t: T): T {
  return t
}

const GraphWithTimeAxis = WithTimeAxis(Graph, identity)
</code></pre>
<p>For <code>CounterExample</code> we are asked to provide a conversion function that takes an object with <code>dayStart: number</code> to <code>dayStart: 0</code>. We could simply provide a conversion function that maps every <code>dayStart</code> (whether it is 1, 2, 99 or something else) to 0 but that would clearly not be in the spirit of <code>WithTimeAxis</code>. If I would instead try to use something <code>identity</code> in this case, TypeScript would complain.</p>
<img src="/articles/images/1g_5XkBVLaWIkvs7W_XHv8g.png" alt="" width="800"/>
<p>which is a rather nice way of hearing about this compilation error I think. (Especially the note at the bottom that says &quot;Type &#x27;number&#x27; is not assignable to type &#x27;0&#x27;&quot; points you in the right direction immediately.)</p>
<p>As we’ve concluded earlier, <code>OuterProps&lt;CounterExampleProps&gt; &amp; TimeAxisProps</code> is not equal to <code>CounterExampleProps</code>, and the compiler can tell you that. If you cannot use something like <code>identity</code> or <code>trivial</code>, that means you probably shouldn’t use this HOC.</p>
<p>This is really the crucial step of this blog, so take some time to digest this. We’ve pushed the burden of proving that <code>OuterProps&lt;InnerProps&gt; &amp; TimeAxisProps</code> to <code>InnerProps</code> from <code>Outer</code> (where that’s hard or even impossible to do) to the consumers of this component (where that is easy or even trivial to do). We can’t prove this in general, but we can do it case-by-case every time we apply <code>WithTimeAxis</code>.</p>
<h2>Leibnizian equality</h2>
<p>A famous mathematician called Leibniz described a form of equality in which two things (<em>a</em> and <em>b</em>) can be considered to be equal if every predicate that holds for <em>a</em> also holds for <em>b</em> (and vice versa).</p>
<p>In TypeScript, we can express this as</p>
<p><code>[leibniz-10-Leibniz.ts](https://gist.github.com/wernerdegroot-blogs/9e26e278c02c700af1845d37632fc28b#file-leibniz-10-Leibniz-ts)</code></p>
<pre><code>type Leibniz&lt;A, B&gt; = ((a: A) =&gt; B) &amp; ((b: B) =&gt; A)
</code></pre>
<p>Two types <code>A</code> and <code>B</code> are equal if every function that maps <code>A</code> to <code>B</code> is also a mapping from <code>B</code> to <code>A</code>. You can see that it’s only possible to construct such a function if <code>A</code> is equal to <code>B</code>. In that case <code>Leibniz&lt;A, B&gt;</code> collapses to <code>type Leibniz&lt;A, A&gt; = (a: A) =&gt; A</code> (in other words, it is our <code>identity</code> function).</p>
<p><code>Leibniz</code> is a formalization of the technique we used in the previous section with a HOC:</p>
<p><code>[leibniz-11-WithTimeAxis.tsx](https://gist.github.com/wernerdegroot-blogs/c584c3e77ed95b7fc5c3bcf39f4460ee#file-leibniz-11-WithTimeAxis-tsx)</code></p>
<pre><code>function WithTimeAxis&lt;InnerProps extends TimeAxisProps&gt;(
  Inner: React.ComponentType&lt;InnerProps&gt;,
  leibniz: Leibniz&lt;OuterProps&lt;InnerProps&gt; &amp; TimeAxisProps, InnerProps&gt;
) {
  return class Outer extends React.Component&lt;OuterProps&lt;InnerProps&gt;, OuterState&gt; {
    
    ...
    
    public render() {
     
      ...
      
      // Combine `OuterProps` and `TimeAxisProps` 
      // to get `InnerProps`.
      const innerProps: InnerProps = leibniz({
        ...this.props,
        ...timeAxisProps
      })
     
      // Render...
      return &lt;Inner {...innerProps} /&gt;
    }
    
    ...
    
  }
}
</code></pre>
<p>By requiring a <code>Leibniz&lt;OuterProps&lt;InnerProps&gt; &amp; TimeAxisProps, InnerProps&gt;</code> this function expresses that it can only do its job if <code>OuterProps&lt;InnerProps&gt; &amp; TimeAxisProps</code> and <code>InnerProps</code> are equal.</p>
<p>Because <code>Leibniz&lt;...&gt;</code> serves as our type constraint, we can even drop the <code>extends</code> from <code>InnerProps extends TimeAxisProps</code>. This is no real loss as that <code>extends</code> wasn’t doing a very good job anyways.</p>
<h2>Conclusion</h2>
<p>Sometimes we need something stricter than <code>extends</code>, or we’d like to constrict the type parameter in the other direction (<code>number extends T</code> instead of <code>T extends number</code>). In those cases <code>Leibniz&lt;...&gt;</code> can be your friend. In my experience using a <code>Leibniz&lt;...&gt;</code> improves the readability of your type constraints when those constraints get more complicated (or include three or more different types).</p>
<h2>Afterthoughts</h2>
<p>This technique was first used in <a href="http://portal.acm.org/citation.cfm?id=583852.581494">Typing Dynamic Typing (Baars and Swierstra, ICFP 2002)</a> but I haven’t seen it used in TypeScript anywhere yet. I’m really interested to hear how you would tackle the problem addressed in this post without using a <code>Leibniz&lt;...&gt;</code> or if you’ve seen it used in similar (or different!) places. Let me know!</p>
<p>[1]: <code>Omit</code> will be introduced in TypeScript 3.5. In the meantime, you can define it yourself as <code>type Omit&lt;O, K extends keyof O&gt; = Pick&lt;O, Exclude&lt;keyof O, K&gt;&gt;</code> .</p>
<p>[2]: We’ve defined <code>OuterProps</code> in terms of <code>InnerProps</code>. Like in mathematics, where you can express <em>y</em> in terms of <em>x</em> (<em>y</em> = 2_x_) or <em>x</em> in terms of <em>y</em> (<em>x</em> = <em>y</em> / 2), TypeScript allows me to reverse this relationship. We get</p>
<p><code>[leibniz-12-InnerProps.ts](https://gist.github.com/wernerdegroot-blogs/260c0917f0f805fb3406f8dbff051cbe#file-leibniz-12-InnerProps-ts)</code></p>
<pre><code>type InnerProps&lt;OuterProps&gt; = OuterProps &amp; TimeAxisProps
</code></pre>
<p>No need for complicated tricks like <code>Omit&lt;...&gt;</code>. Unfortunately, this doesn’t work. Because we start out with an <code>Inner</code>-component, from which we generate an <code>Outer</code>-component, we should start out with an <code>InnerProps</code>, from which we derive the <code>OuterProps</code>. If we would reverse this relationship by writing</p>
<p><code>[leibniz-13-WithTimeAxis.tsx](https://gist.github.com/wernerdegroot-blogs/21a456a053cec1f303a5f6f2a4a26506#file-leibniz-13-WithTimeAxis-tsx)</code></p>
<pre><code>type InnerProps&lt;OuterProps&gt; = OuterProps &amp; TimeAxisProps

function WithTimeAxis&lt;OuterProps&gt;(Inner: React.ComponentType&lt;InnerProps&lt;OuterProps&gt;&gt;) {
  return class Outer extends React.Component&lt;OuterProps, OuterState&gt; {

    ...

  }
}
</code></pre>
<p>we&#x27;d lose the ability for TypeScript to correctly infer the right types:</p>
<img src="/articles/images/1JmOikDAspLJuHPY07W1-Lw.png" alt="" width="800"/>
<p>In our example, the compiler would infer <code>OuterProps</code> to be equal to <code>GraphProps</code>, which includes <code>dayStart</code>, <code>dayEnd</code>, <code>onZoomIn</code> and <code>onZoomOut</code> so when you try to use the resulting component you are still asked to provide those props (even though they will by overwritten by the ones the HOC provides).</p>
<p>If you don’t mind helping the compiler a hand by providing the type yourself (instead of letting TypeScript infer it) then this is a very nice way of writing HOC’s and you needn’t read the rest of the blog.</p></main></div><footer class="Footer_footer__OYoYH"><div><ul class="contact-info"><li><a href="mailto:codestar@ordina.nl">codestar.nl@soprasteria.com</a></li><li><a href="tel:+31306637000">+31 30 6637000</a></li><li><a href="https://maps.google.com/maps?ll=52.057652,5.111462&amp;z=16&amp;t=m&amp;hl=en-GB&amp;gl=NL&amp;mapclient=embed&amp;cid=15918536717636328792" target="_blank" rel="noopener noreferrer">Ringwade 1, 3439 LM Nieuwegein</a></li></ul><p class="social-links"><a href="https://mastodon.social/@codestar" aria-label="Mastodon" rel="me"><img alt="Codestar Mastodon" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" style="color:transparent" src="/mastodon_logo.svg"/></a><a href="https://github.com/code-star" aria-label="Github"><img alt="Codestar Github" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" style="color:transparent" src="/github_logo.svg"/></a><a href="https://medium.com/codestar-blog" aria-label="Medium"><img alt="Codestar Medium" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" style="color:transparent" src="/medium_logo.svg"/></a><a href="https://www.linkedin.com/company/codestar-powered-by-sopra-steria/" aria-label="Linkedin"><img alt="Codestar LinkedIn" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" style="color:transparent" src="/linkedin_logo.svg"/></a><a href="https://www.youtube.com/channel/UCqwHhJNEUe7D-HGsX4zvKzQ" aria-label="Youtube"><img alt="Codestar Youtube" loading="lazy" width="36" height="32" decoding="async" data-nimg="1" style="color:transparent" src="/youtube_logo.svg"/></a><a href="https://www.meetup.com/Code-Star-Night" aria-label="Meetup.com"><img alt="Codestar Meetup" loading="lazy" width="32" height="32" decoding="async" data-nimg="1" style="color:transparent" src="/meetup_logo.svg"/></a></p></div></footer><script src="/_next/static/chunks/webpack-bafee5ae243c8c89.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n4:I[8173,[\"970\",\"static/chunks/970-4a0f7daee52c7cff.js\",\"173\",\"static/chunks/173-77a4cc13cb7e18d3.js\",\"571\",\"static/chunks/app/articles/%5Bslug%5D/layout-0f8ac0524a72511b.js\"],\"\"]\n5:I[7970,[\"970\",\"static/chunks/970-4a0f7daee52c7cff.js\",\"904\",\"static/chunks/app/articles/%5Bslug%5D/page-c42cdda36797932a.js\"],\"Image\"]\n7:I[6213,[],\"OutletBoundary\"]\n9:I[6213,[],\"MetadataBoundary\"]\nb:I[6213,[],\"ViewportBoundary\"]\nd:I[4835,[],\"\"]\n:HL[\"/_next/static/media/4cf2300e9c8272f7-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/deecf931bfbdc38e.css\",\"style\"]\n:HL[\"/_next/static/css/13422ae1d848e043.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"nuWv889VLUOIFLUIxBwBi\",\"p\":\"\",\"c\":[\"\",\"articles\",\"20190403-leibniz-equality-in-typescript-2aeff1303749\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"articles\",{\"children\":[[\"slug\",\"20190403-leibniz-equality-in-typescript-2aeff1303749\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/deecf931bfbdc38e.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_188709 __variable_9a8899\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"articles\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"articles\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"20190403-leibniz-equality-in-typescript-2aeff1303749\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/13422ae1d848e043.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[null,[\"$\",\"nav\",null,{\"className\":\"TopBar_top-bar__RDkoF\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"$L4\",null,{\"href\":\"/\",\"children\":[\"$\",\"$L5\",null,{\"src\":\"/codestar_logo_cream-red.svg\",\"alt\":\"Codestar Logo\",\"width\":150,\"height\":40}]}],[\"$\",\"ul\",null,{\"children\":[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://www.linkedin.com/company/codestar-powered-by-sopra-steria/\",\"children\":\"Contact\"}]}]}]]}]}],[\"$\",\"div\",null,{\"className\":\"layout_content__K15KO\",\"children\":[\"$\",\"main\",null,{\"className\":\"layout_main__Afkre\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"articles\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}],[\"$\",\"footer\",null,{\"className\":\"Footer_footer__OYoYH\",\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"ul\",null,{\"className\":\"contact-info\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"mailto:codestar@ordina.nl\",\"children\":\"codestar.nl@soprasteria.com\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"tel:+31306637000\",\"children\":\"+31 30 6637000\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://maps.google.com/maps?ll=52.057652,5.111462\u0026z=16\u0026t=m\u0026hl=en-GB\u0026gl=NL\u0026mapclient=embed\u0026cid=15918536717636328792\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"children\":\"Ringwade 1, 3439 LM Nieuwegein\"}]}]]}],[\"$\",\"p\",null,{\"className\":\"social-links\",\"children\":[[\"$\",\"a\",null,{\"href\":\"https://mastodon.social/@codestar\",\"aria-label\":\"Mastodon\",\"rel\":\"me\",\"children\":[\"$\",\"$L5\",null,{\"src\":\"/mastodon_logo.svg\",\"alt\":\"Codestar Mastodon\",\"width\":32,\"height\":32}]}],[\"$\",\"a\",null,{\"href\":\"https://github.com/code-star\",\"aria-label\":\"Github\",\"children\":[\"$\",\"$L5\",null,{\"src\":\"/github_logo.svg\",\"alt\":\"Codestar Github\",\"width\":32,\"height\":32}]}],[\"$\",\"a\",null,{\"href\":\"https://medium.com/codestar-blog\",\"aria-label\":\"Medium\",\"children\":[\"$\",\"$L5\",null,{\"src\":\"/medium_logo.svg\",\"alt\":\"Codestar Medium\",\"width\":32,\"height\":32}]}],[\"$\",\"a\",null,{\"href\":\"https://www.linkedin.com/company/codestar-powered-by-sopra-steria/\",\"aria-label\":\"Linkedin\",\"children\":[\"$\",\"$L5\",null,{\"src\":\"/linkedin_logo.svg\",\"alt\":\"Codestar LinkedIn\",\"width\":32,\"height\":32}]}],[\"$\",\"a\",null,{\"href\":\"https://www.youtube.com/channel/UCqwHhJNEUe7D-HGsX4zvKzQ\",\"aria-label\":\"Youtube\",\"children\":[\"$\",\"$L5\",null,{\"src\":\"/youtube_logo.svg\",\"alt\":\"Codestar Youtube\",\"width\":36,\"height\":32}]}],[\"$\",\"a\",null,{\"href\":\"https://www.meetup.com/Code-Star-Night\",\"aria-label\":\"Meetup.com\",\"children\":[\"$\",\"$L5\",null,{\"src\":\"/meetup_logo.svg\",\"alt\":\"Codestar Meetup\",\"width\":32,\"height\":32}]}]]}]]}]}]]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L6\",null,[\"$\",\"$L7\",null,{\"children\":\"$L8\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"o5EtNXXYjsufP6R_GKoYs\",{\"children\":[[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$d\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"e:I[9214,[\"970\",\"static/chunks/970-4a0f7daee52c7cff.js\",\"904\",\"static/chunks/app/articles/%5Bslug%5D/page-c42cdda36797932a.js\"],\"PreloadChunks\"]\n6:[[\"$\",\"h1\",null,{\"children\":\"Leibniz equality in TypeScript\"}],[\"$\",\"p\",null,{\"children\":[\"Published at \",\"2019-04-03\",\" by \",\"Werner de Groot\"]}],[[\"$\",\"$Le\",null,{\"moduleIds\":\"$undefined\"}],\"$Lf\"]]\n"])</script><script>self.__next_f.push([1,"10:T615,// The state that we want to manage for `Inner`:\ntype OuterState = {\n  dayStart: number\n  dayEnd: number\n}\n\nfunction WithTimeAxis\u003cInnerProps extends TimeAxisProps\u003e(Inner: React.ComponentType\u003cInnerProps\u003e) {\n  return class Outer extends React.Component\u003cOuterProps\u003cInnerProps\u003e, OuterState\u003e {\n    constructor(props: OuterProps\u003cInnerProps\u003e) {\n      super(props)\n      \n      // Choose a sensible default state:\n      this.state = {\n        dayStart: 0,\n        dayEnd: 10\n      }\n    }\n    \n    public render() {\n      // Construct `TimeAxisProps`.\n      const timeAxisProps: TimeAxisProps = {\n        dayStart: this.state.dayStart,\n        dayEnd: this.state.dayEnd,\n        onZoomIn: this.handleZoomIn,\n        onZoomOut: this.handleZoomOut\n      }\n      \n      // Combine `OuterProps` and `TimeAxisProps` \n      // to get `InnerProps`.\n      const innerProps: InnerProps = {\n        ...this.props,\n        ...timeAxisProps\n      }\n     \n      // Render...\n      return \u003cInner {...innerProps} /\u003e\n    }\n    \n    private handleZoomOut = () =\u003e {\n     const [newDayStart, newDayEnd] = zoom(\n        this.state.dayStart,\n        this.state.dayEnd,\n        2 // Make the time range twice as big\n      )\n      this.setState({ dayStart: newDayStart, dayEnd: newDayEnd })\n    }\n    \n    private handleZoomIn = () =\u003e {\n      const [newDayStart, newDayEnd] = zoom(\n        this.state.dayStart,\n        this.state.dayEnd,\n        0.5 // Make the time range half as big (twice as small)\n      )\n      this.setState({ dayStart: newDayStart, dayEnd: newDayEnd })\n    }\n  }\n}\n"])</script><script>self.__next_f.push([1,"f:[[\"$\",\"p\",null,{\"children\":\"In this post I’ll explain how you can use Leibniz equality to safely type your higher-order components in React, although it can be used in many other places (outside the React ecosystem) too.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Introduction\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"At the client I’m currently working for we use a lot of different charts to visualize processes over time. We have line charts, Gantt charts, you name it. Each of those charts features buttons which allows users to zoom in or out.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"I’d like to use a simplified version of one of those graphs to explain what Leibniz, a German mathematician who lived well over 300 years ago, has to do with TypeScript.\"}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Motivating example\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Let's suppose our graph looks a bit like this:\"}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/articles/images/1iBVlr8lOKvIzbqA8-qvHoQ.gif\",\"alt\":\"\",\"width\":\"494\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"I use a component \",[\"$\",\"code\",null,{\"children\":\"Graph\"}],\" which takes the following props:\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[GraphProps.ts](https://gist.github.com/wernerdegroot-blogs/233ddd104b1e58f14382de69080c7f9f#file-GraphProps-ts)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"type GraphProps = {\\n  activities: Activity[]\\n  dayStart: number\\n  dayEnd: number\\n  onZoomIn: () =\u003e void\\n  onZoomOut: () =\u003e void\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"What do we need to show a graph? We need:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"activities\"}],\" to show;\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"dayStart\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"dayEnd\"}],\", which specify the range of the time axis;\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"onZoomIn\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"onZoomOut\"}],\" to control the range of the time axis from inside the component.\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Zooming in and out\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In this aside, I’d like to show you the function that handles zooming in or out. It’s not really relevant to the rest of the story (and you can skip this if you like) but it might come in handy if you wish to code along with this blog post.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[zoom.ts](https://gist.github.com/wernerdegroot-blogs/ba3ebc50d0c63c54bd89d6672b7edaa7#file-zoom-ts)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"function zoom(dayStart: number, dayEnd: number, zoomFactor: number): [number, number] {\\n  // What is the middle of the time range?\\n  // When zooming in or out, the middle of the time range should stay the middle.\\n  const dayMiddle = (dayEnd + dayStart) / 2\\n \\n  // Determine what the new time range should be using the `zoomFactor`.\\n  const oldTimeRange = dayEnd - dayStart\\n  const newTimeRange = oldTimeRange * zoomFactor\\n \\n  // Calculate the new boundaries of the time range:\\n  const newDayStart = dayMiddle - newTimeRange / 2\\n  const newDayEnd = dayMiddle + newTimeRange / 2\\n  \\n  return [newDayStart, newDayEnd]\\n}\\n\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Higher-order component\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Although it is tempting to let this component manage its own \",[\"$\",\"code\",null,{\"children\":\"dayStart\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"dayEnd\"}],\" (especially now that we can use hooks), it has two benefits to manage that state externally:\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"I can easily expose the component to different states, which makes it easy to test;\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"I can change that state from the outside if I need to (for instance to ensure that all visible charts share the same time axis).\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"If I would create a higher-order component (HOC) to manage that state for me, I would get the best of both worlds. I get an easy to use component which manages its own state if I wrap \",[\"$\",\"code\",null,{\"children\":\"Graph\"}],\" in this HOC, but I get a lot of power if I choose not to.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Furthermore, I can apply this HOC to many other components which have a time axis and support some form of zooming in and out.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"What should this HOC look like? What is the input? And what is the output?\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"The component that we pass to the HOC (the “inner component”) should have some props provided automatically by the component that the HOC produces (the “outer component”).\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"The outer component should forward any other props to the inner component. Those are the only props that we need to provide to the outer component.\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"TypeScript should be able to infer all of this automatically.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The HOC we will write will provide the following props to the inner component (which we’ll call \",[\"$\",\"code\",null,{\"children\":\"Inner\"}],\" in what follows):\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[leibniz-03-TimeAxisProps.ts](https://gist.github.com/wernerdegroot-blogs/d2ab9d1b04b4170309dd81b5b85db6c5#file-leibniz-03-TimeAxisProps-ts)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"type TimeAxisProps = {\\n  dayStart: number\\n  dayEnd: number\\n  onZoomIn: () =\u003e void\\n  onZoomOut: () =\u003e void\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"It will produce a component (which we’ll call \",[\"$\",\"code\",null,{\"children\":\"Outer\"}],\" from now on) that takes the following props¹:\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[leibniz-04-OuterProps.ts](https://gist.github.com/wernerdegroot-blogs/f8dc13b757ddbba78bcd5d01d14e8c1a#file-leibniz-04-OuterProps-ts)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"type OuterProps\u003cInnerProps\u003e = Omit\u003cInnerProps, keyof TimeAxisProps\u003e\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"This might be a bit intimidating. What this says is that we can determine the props to the outer component (\",[\"$\",\"code\",null,{\"children\":\"OuterProps\"}],\") from the props to the inner component (\",[\"$\",\"code\",null,{\"children\":\"InnerProps\"}],\") by removing all values that are shared with \",[\"$\",\"code\",null,{\"children\":\"TimeAxisProps\"}],\" (\",[\"$\",\"code\",null,{\"children\":\"dayStart\"}],\", \",[\"$\",\"code\",null,{\"children\":\"dayEnd\"}],\", \",[\"$\",\"code\",null,{\"children\":\"onZoomIn\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"onZoomOut\"}],\" to be precise)².\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Now that we know what the HOC should do, we can focus on \",[\"$\",\"em\",null,{\"children\":\"how\"}],\" it should do it:\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[leibniz-05-WithTimeAxis.tsx](https://gist.github.com/wernerdegroot-blogs/5a37a833eed02e85f937572087bd09fc#file-leibniz-05-WithTimeAxis-tsx)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"$10\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"That’s a big piece of code! We can see how to handle zooming in and zooming out. We can also see how we can combine both the \",[\"$\",\"code\",null,{\"children\":\"OuterProps\"}],\" and the \",[\"$\",\"code\",null,{\"children\":\"TimeAxisProps\"}],\" to render the \",[\"$\",\"code\",null,{\"children\":\"Inner\"}],\"-component. You might also have noticed that \",[\"$\",\"code\",null,{\"children\":\"InnerProps extends TimeAxisProps\"}],\". Constraining our generic type parameter it this way ensures that we can only apply this HOC on components that have at least the props \",[\"$\",\"code\",null,{\"children\":\"dayStart\"}],\", \",[\"$\",\"code\",null,{\"children\":\"dayEnd\"}],\", \",[\"$\",\"code\",null,{\"children\":\"onZoomIn\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"onZoomOut\"}],\" that we’d like to provide to it. If that component doesn’t have these four props, why even apply \",[\"$\",\"code\",null,{\"children\":\"WithTimeAxis\"}],\", right?\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Trouble\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"There is, however, a tiny problem… It doesn't compile!\"}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/articles/images/16mEccGy9WNOJ5zU_8a35DA.png\",\"alt\":\"\",\"width\":\"800\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"But why doesn't it? TypeScript has trouble figuring out that the combination of \",[\"$\",\"code\",null,{\"children\":\"OuterProps\u003cInnerProps\u003e\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"TimeAxisProps\"}],\" is equal to \",[\"$\",\"code\",null,{\"children\":\"InnerProps\"}],\". Although this is true for the case with \",[\"$\",\"code\",null,{\"children\":\"GraphProps\"}],\", it isn't true in general.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"To give you an example in which this isn’t true, let’s suppose that we try to apply the HOC to a component \",[\"$\",\"code\",null,{\"children\":\"CounterExample\"}],\" with the following props:\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[leibniz-06-CounterExampleProps.ts](https://gist.github.com/wernerdegroot-blogs/17879a042e2df6fbf7be765fb07fc6b8#file-leibniz-06-CounterExampleProps-ts)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"type CounterExampleProps = {\\n  activities: Activity[]\\n  dayStart: 0 // Can only start at zero!\\n  dayEnd: number\\n  onZoomIn: () =\u003e void\\n  onZoomOut: () =\u003e void\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"where I’d like to point your attention to the \",[\"$\",\"code\",null,{\"children\":\"dayStart: 0\"}],\".\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"I admit, this is a bit farfetched, but it does illustrate the point. We shouldn’t apply \",[\"$\",\"code\",null,{\"children\":\"WithTimeAxis\"}],\" to \",[\"$\",\"code\",null,{\"children\":\"CounterExample\"}],\" as the HOC might provide a \",[\"$\",\"code\",null,{\"children\":\"dayStart\"}],\" that is not equal to zero. In fact, changing the zoom level multiple times ensures that \",[\"$\",\"code\",null,{\"children\":\"dayStart\"}],\" will eventually be non-zero, even if it was equal to zero initially.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The TypeScript isn’t complaining about this when we do try to apply \",[\"$\",\"code\",null,{\"children\":\"WithTimeAxis\"}],\" to \",[\"$\",\"code\",null,{\"children\":\"CounterExample\"}],\", as \",[\"$\",\"code\",null,{\"children\":\"CounterExampleProps\"}],\" nicely extends \",[\"$\",\"code\",null,{\"children\":\"TimeAxisProps\"}],\" as I required. \",[\"$\",\"code\",null,{\"children\":\"CounterExampleProps\"}],\" is more specific than \",[\"$\",\"code\",null,{\"children\":\"TimeAxisProps\"}],\" (because the type \",[\"$\",\"code\",null,{\"children\":\"0\"}],\" is more specific than \",[\"$\",\"code\",null,{\"children\":\"number\"}],\") but that is allowed for subtypes. Instead, the compiler has noticed this possibility even before we did, and that is why our HOC doesn’t compile!\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The root of our issues is with the \",[\"$\",\"code\",null,{\"children\":\"InnerProps extends TimeAxisProps\"}],\" constraint. What we try to express is that all properties of \",[\"$\",\"code\",null,{\"children\":\"TimeAxisProps\"}],\" are shared with \",[\"$\",\"code\",null,{\"children\":\"InnerProps\"}],\" without allowing for subtypes. Unfortunately \",[\"$\",\"code\",null,{\"children\":\"extends\"}],\" is currently the best we can do. In fact, it’s the only type of constraint we can express on our generic type parameters in TypeScript.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Hope on the horizon\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"We can solve this problem by pushing the burden of proof up a level. We ask the user for a function \",[\"$\",\"code\",null,{\"children\":\"convert\"}],\" that is able to convert the combination of \",[\"$\",\"code\",null,{\"children\":\"OuterProps\u003cInnerProps\u003e\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"TimeAxisProps\"}],\" (which can be expressed in TypeScript as \",[\"$\",\"code\",null,{\"children\":\"OuterProps\u003cInnerProps\u003e \u0026 TimeAxisProps\"}],\") to \",[\"$\",\"code\",null,{\"children\":\"InnerProps\"}],\". If the user can do that, we can call \",[\"$\",\"code\",null,{\"children\":\"Inner\"}],\" with the right props:\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[leibniz-07-WithTimeAxis.tsx](https://gist.github.com/wernerdegroot-blogs/b0ce2eb9479c9d548b4ce3495bb211a5#file-leibniz-07-WithTimeAxis-tsx)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"function WithTimeAxis\u003cInnerProps extends TimeAxisProps\u003e(\\n  Inner: React.ComponentType\u003cInnerProps\u003e,\\n  convert: (p: OuterProps\u003cInnerProps\u003e \u0026 TimeAxisProps) =\u003e InnerProps\\n) {\\n  return class Outer extends React.Component\u003cOuterProps\u003cInnerProps\u003e, OuterState\u003e {\\n    \\n    ...\\n    \\n    public render() {\\n     \\n      ...\\n      \\n      // Combine `OuterProps` and `TimeAxisProps` \\n      // to get `InnerProps`.\\n      const innerProps: InnerProps = convert({\\n        ...this.props,\\n        ...timeAxisProps\\n      })\\n     \\n      // Render...\\n      return \u003cInner {...innerProps} /\u003e\\n    }\\n    \\n    ...\\n    \\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"What does this conversion function look like in the example of \",[\"$\",\"code\",null,{\"children\":\"GraphProps\"}],\"? It’s not very difficult at all! In the example of \",[\"$\",\"code\",null,{\"children\":\"GraphProps\"}],\" we can see that:\"]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"The parameter type is \",[\"$\",\"code\",null,{\"children\":\"Omit\u003cGraphProps, keyof TimeAxisProps\u003e \u0026 TimeAxisProps\"}],\", which the compiler knows is just a fancy way to write \",[\"$\",\"code\",null,{\"children\":\"GraphProps\"}],\";\"]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"The return type is \",[\"$\",\"code\",null,{\"children\":\"GraphProps\"}],\".\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"What it boils down to is that we are asked to provide a function that makes this very trivial conversion:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[leibniz-08-trivial.ts](https://gist.github.com/wernerdegroot-blogs/9e53339b4ed8a0485174812ddea9823e#file-leibniz-08-trivial-ts)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"function trivial(graphProps: GraphProps): GraphProps {\\n  return graphProps\\n}\\n\\nconst GraphWithTimeAxis = WithTimeAxis(Graph, trivial)\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We can even use the identity function if we’d like:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[leibniz-09-identity.ts](https://gist.github.com/wernerdegroot-blogs/0c0d992f20045903fc0e50233d7f64dc#file-leibniz-09-identity-ts)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"function identity\u003cT\u003e(t: T): T {\\n  return t\\n}\\n\\nconst GraphWithTimeAxis = WithTimeAxis(Graph, identity)\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"For \",[\"$\",\"code\",null,{\"children\":\"CounterExample\"}],\" we are asked to provide a conversion function that takes an object with \",[\"$\",\"code\",null,{\"children\":\"dayStart: number\"}],\" to \",[\"$\",\"code\",null,{\"children\":\"dayStart: 0\"}],\". We could simply provide a conversion function that maps every \",[\"$\",\"code\",null,{\"children\":\"dayStart\"}],\" (whether it is 1, 2, 99 or something else) to 0 but that would clearly not be in the spirit of \",[\"$\",\"code\",null,{\"children\":\"WithTimeAxis\"}],\". If I would instead try to use something \",[\"$\",\"code\",null,{\"children\":\"identity\"}],\" in this case, TypeScript would complain.\"]}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/articles/images/1g_5XkBVLaWIkvs7W_XHv8g.png\",\"alt\":\"\",\"width\":\"800\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"which is a rather nice way of hearing about this compilation error I think. (Especially the note at the bottom that says \\\"Type 'number' is not assignable to type '0'\\\" points you in the right direction immediately.)\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"As we’ve concluded earlier, \",[\"$\",\"code\",null,{\"children\":\"OuterProps\u003cCounterExampleProps\u003e \u0026 TimeAxisProps\"}],\" is not equal to \",[\"$\",\"code\",null,{\"children\":\"CounterExampleProps\"}],\", and the compiler can tell you that. If you cannot use something like \",[\"$\",\"code\",null,{\"children\":\"identity\"}],\" or \",[\"$\",\"code\",null,{\"children\":\"trivial\"}],\", that means you probably shouldn’t use this HOC.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"This is really the crucial step of this blog, so take some time to digest this. We’ve pushed the burden of proving that \",[\"$\",\"code\",null,{\"children\":\"OuterProps\u003cInnerProps\u003e \u0026 TimeAxisProps\"}],\" to \",[\"$\",\"code\",null,{\"children\":\"InnerProps\"}],\" from \",[\"$\",\"code\",null,{\"children\":\"Outer\"}],\" (where that’s hard or even impossible to do) to the consumers of this component (where that is easy or even trivial to do). We can’t prove this in general, but we can do it case-by-case every time we apply \",[\"$\",\"code\",null,{\"children\":\"WithTimeAxis\"}],\".\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Leibnizian equality\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"A famous mathematician called Leibniz described a form of equality in which two things (\",[\"$\",\"em\",null,{\"children\":\"a\"}],\" and \",[\"$\",\"em\",null,{\"children\":\"b\"}],\") can be considered to be equal if every predicate that holds for \",[\"$\",\"em\",null,{\"children\":\"a\"}],\" also holds for \",[\"$\",\"em\",null,{\"children\":\"b\"}],\" (and vice versa).\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In TypeScript, we can express this as\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[leibniz-10-Leibniz.ts](https://gist.github.com/wernerdegroot-blogs/9e26e278c02c700af1845d37632fc28b#file-leibniz-10-Leibniz-ts)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"type Leibniz\u003cA, B\u003e = ((a: A) =\u003e B) \u0026 ((b: B) =\u003e A)\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Two types \",[\"$\",\"code\",null,{\"children\":\"A\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"B\"}],\" are equal if every function that maps \",[\"$\",\"code\",null,{\"children\":\"A\"}],\" to \",[\"$\",\"code\",null,{\"children\":\"B\"}],\" is also a mapping from \",[\"$\",\"code\",null,{\"children\":\"B\"}],\" to \",[\"$\",\"code\",null,{\"children\":\"A\"}],\". You can see that it’s only possible to construct such a function if \",[\"$\",\"code\",null,{\"children\":\"A\"}],\" is equal to \",[\"$\",\"code\",null,{\"children\":\"B\"}],\". In that case \",[\"$\",\"code\",null,{\"children\":\"Leibniz\u003cA, B\u003e\"}],\" collapses to \",[\"$\",\"code\",null,{\"children\":\"type Leibniz\u003cA, A\u003e = (a: A) =\u003e A\"}],\" (in other words, it is our \",[\"$\",\"code\",null,{\"children\":\"identity\"}],\" function).\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"Leibniz\"}],\" is a formalization of the technique we used in the previous section with a HOC:\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[leibniz-11-WithTimeAxis.tsx](https://gist.github.com/wernerdegroot-blogs/c584c3e77ed95b7fc5c3bcf39f4460ee#file-leibniz-11-WithTimeAxis-tsx)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"function WithTimeAxis\u003cInnerProps extends TimeAxisProps\u003e(\\n  Inner: React.ComponentType\u003cInnerProps\u003e,\\n  leibniz: Leibniz\u003cOuterProps\u003cInnerProps\u003e \u0026 TimeAxisProps, InnerProps\u003e\\n) {\\n  return class Outer extends React.Component\u003cOuterProps\u003cInnerProps\u003e, OuterState\u003e {\\n    \\n    ...\\n    \\n    public render() {\\n     \\n      ...\\n      \\n      // Combine `OuterProps` and `TimeAxisProps` \\n      // to get `InnerProps`.\\n      const innerProps: InnerProps = leibniz({\\n        ...this.props,\\n        ...timeAxisProps\\n      })\\n     \\n      // Render...\\n      return \u003cInner {...innerProps} /\u003e\\n    }\\n    \\n    ...\\n    \\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"By requiring a \",[\"$\",\"code\",null,{\"children\":\"Leibniz\u003cOuterProps\u003cInnerProps\u003e \u0026 TimeAxisProps, InnerProps\u003e\"}],\" this function expresses that it can only do its job if \",[\"$\",\"code\",null,{\"children\":\"OuterProps\u003cInnerProps\u003e \u0026 TimeAxisProps\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"InnerProps\"}],\" are equal.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Because \",[\"$\",\"code\",null,{\"children\":\"Leibniz\u003c...\u003e\"}],\" serves as our type constraint, we can even drop the \",[\"$\",\"code\",null,{\"children\":\"extends\"}],\" from \",[\"$\",\"code\",null,{\"children\":\"InnerProps extends TimeAxisProps\"}],\". This is no real loss as that \",[\"$\",\"code\",null,{\"children\":\"extends\"}],\" wasn’t doing a very good job anyways.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Conclusion\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"Sometimes we need something stricter than \",[\"$\",\"code\",null,{\"children\":\"extends\"}],\", or we’d like to constrict the type parameter in the other direction (\",[\"$\",\"code\",null,{\"children\":\"number extends T\"}],\" instead of \",[\"$\",\"code\",null,{\"children\":\"T extends number\"}],\"). In those cases \",[\"$\",\"code\",null,{\"children\":\"Leibniz\u003c...\u003e\"}],\" can be your friend. In my experience using a \",[\"$\",\"code\",null,{\"children\":\"Leibniz\u003c...\u003e\"}],\" improves the readability of your type constraints when those constraints get more complicated (or include three or more different types).\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"Afterthoughts\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"This technique was first used in \",[\"$\",\"a\",null,{\"href\":\"http://portal.acm.org/citation.cfm?id=583852.581494\",\"children\":\"Typing Dynamic Typing (Baars and Swierstra, ICFP 2002)\"}],\" but I haven’t seen it used in TypeScript anywhere yet. I’m really interested to hear how you would tackle the problem addressed in this post without using a \",[\"$\",\"code\",null,{\"children\":\"Leibniz\u003c...\u003e\"}],\" or if you’ve seen it used in similar (or different!) places. Let me know!\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"[1]: \",[\"$\",\"code\",null,{\"children\":\"Omit\"}],\" will be introduced in TypeScript 3.5. In the meantime, you can define it yourself as \",[\"$\",\"code\",null,{\"children\":\"type Omit\u003cO, K extends keyof O\u003e = Pick\u003cO, Exclude\u003ckeyof O, K\u003e\u003e\"}],\" .\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"[2]: We’ve defined \",[\"$\",\"code\",null,{\"children\":\"OuterProps\"}],\" in terms of \",[\"$\",\"code\",null,{\"children\":\"InnerProps\"}],\". Like in mathematics, where you can express \",[\"$\",\"em\",null,{\"children\":\"y\"}],\" in terms of \",[\"$\",\"em\",null,{\"children\":\"x\"}],\" (\",[\"$\",\"em\",null,{\"children\":\"y\"}],\" = 2_x_) or \",[\"$\",\"em\",null,{\"children\":\"x\"}],\" in terms of \",[\"$\",\"em\",null,{\"children\":\"y\"}],\" (\",[\"$\",\"em\",null,{\"children\":\"x\"}],\" = \",[\"$\",\"em\",null,{\"children\":\"y\"}],\" / 2), TypeScript allows me to reverse this relationship. We get\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[leibniz-12-InnerProps.ts](https://gist.github.com/wernerdegroot-blogs/260c0917f0f805fb3406f8dbff051cbe#file-leibniz-12-InnerProps-ts)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"type InnerProps\u003cOuterProps\u003e = OuterProps \u0026 TimeAxisProps\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"No need for complicated tricks like \",[\"$\",\"code\",null,{\"children\":\"Omit\u003c...\u003e\"}],\". Unfortunately, this doesn’t work. Because we start out with an \",[\"$\",\"code\",null,{\"children\":\"Inner\"}],\"-component, from which we generate an \",[\"$\",\"code\",null,{\"children\":\"Outer\"}],\"-component, we should start out with an \",[\"$\",\"code\",null,{\"children\":\"InnerProps\"}],\", from which we derive the \",[\"$\",\"code\",null,{\"children\":\"OuterProps\"}],\". If we would reverse this relationship by writing\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"[leibniz-13-WithTimeAxis.tsx](https://gist.github.com/wernerdegroot-blogs/21a456a053cec1f303a5f6f2a4a26506#file-leibniz-13-WithTimeAxis-tsx)\"}]}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"children\":\"type InnerProps\u003cOuterProps\u003e = OuterProps \u0026 TimeAxisProps\\n\\nfunction WithTimeAxis\u003cOuterProps\u003e(Inner: React.ComponentType\u003cInnerProps\u003cOuterProps\u003e\u003e) {\\n  return class Outer extends React.Component\u003cOuterProps, OuterState\u003e {\\n\\n    ...\\n\\n  }\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"we'd lose the ability for TypeScript to correctly infer the right types:\"}],\"\\n\",[\"$\",\"img\",null,{\"src\":\"/articles/images/1JmOikDAspLJuHPY07W1-Lw.png\",\"alt\":\"\",\"width\":\"800\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"In our example, the compiler would infer \",[\"$\",\"code\",null,{\"children\":\"OuterProps\"}],\" to be equal to \",[\"$\",\"code\",null,{\"children\":\"GraphProps\"}],\", which includes \",[\"$\",\"code\",null,{\"children\":\"dayStart\"}],\", \",[\"$\",\"code\",null,{\"children\":\"dayEnd\"}],\", \",[\"$\",\"code\",null,{\"children\":\"onZoomIn\"}],\" and \",[\"$\",\"code\",null,{\"children\":\"onZoomOut\"}],\" so when you try to use the resulting component you are still asked to provide those props (even though they will by overwritten by the ones the HOC provides).\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"If you don’t mind helping the compiler a hand by providing the type yourself (instead of letting TypeScript infer it) then this is a very nice way of writing HOC’s and you needn’t read the rest of the blog.\"}]]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\na:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Codestar\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"Codestar - a Sopra Steria team\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script></body></html>