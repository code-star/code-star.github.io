1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
4:I[8173,["970","static/chunks/970-4a0f7daee52c7cff.js","173","static/chunks/173-77a4cc13cb7e18d3.js","571","static/chunks/app/articles/%5Bslug%5D/layout-0f8ac0524a72511b.js"],""]
5:I[7970,["970","static/chunks/970-4a0f7daee52c7cff.js","904","static/chunks/app/articles/%5Bslug%5D/page-c42cdda36797932a.js"],"Image"]
7:I[6213,[],"OutletBoundary"]
9:I[6213,[],"MetadataBoundary"]
b:I[6213,[],"ViewportBoundary"]
d:I[4835,[],""]
:HL["/_next/static/media/4cf2300e9c8272f7-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/deecf931bfbdc38e.css","style"]
:HL["/_next/static/css/13422ae1d848e043.css","style"]
0:{"P":null,"b":"GACyIuJtcHOcwb14PbY67","p":"","c":["","articles","20190501-sharing-is-caring-domain-objects-in-both-scala-and-r-with-graalvm-polyglot-bindings-b561e8cfbcfa"],"i":false,"f":[[["",{"children":["articles",{"children":[["slug","20190501-sharing-is-caring-domain-objects-in-both-scala-and-r-with-graalvm-polyglot-bindings-b561e8cfbcfa","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/deecf931bfbdc38e.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_188709 __variable_9a8899","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["articles",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","articles","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","20190501-sharing-is-caring-domain-objects-in-both-scala-and-r-with-graalvm-polyglot-bindings-b561e8cfbcfa","d"],["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/13422ae1d848e043.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],[null,["$","nav",null,{"className":"TopBar_top-bar__RDkoF","children":["$","div",null,{"children":[["$","$L4",null,{"href":"/","children":["$","$L5",null,{"src":"/codestar_logo_cream-red.svg","alt":"Codestar Logo","width":150,"height":40}]}],["$","ul",null,{"children":["$","li",null,{"children":["$","a",null,{"href":"https://www.linkedin.com/company/codestar-powered-by-sopra-steria/","children":"Contact"}]}]}]]}]}],["$","div",null,{"className":"layout_content__K15KO","children":["$","main",null,{"className":"layout_main__Afkre","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","articles","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]}],["$","footer",null,{"className":"Footer_footer__OYoYH","children":["$","div",null,{"children":[["$","ul",null,{"className":"contact-info","children":[["$","li",null,{"children":["$","a",null,{"href":"mailto:codestar@ordina.nl","children":"codestar.nl@soprasteria.com"}]}],["$","li",null,{"children":["$","a",null,{"href":"tel:+31306637000","children":"+31 30 6637000"}]}],["$","li",null,{"children":["$","a",null,{"href":"https://maps.google.com/maps?ll=52.057652,5.111462&z=16&t=m&hl=en-GB&gl=NL&mapclient=embed&cid=15918536717636328792","target":"_blank","rel":"noopener noreferrer","children":"Ringwade 1, 3439 LM Nieuwegein"}]}]]}],["$","p",null,{"className":"social-links","children":[["$","a",null,{"href":"https://mastodon.social/@codestar","aria-label":"Mastodon","rel":"me","children":["$","$L5",null,{"src":"/mastodon_logo.svg","alt":"Codestar Mastodon","width":32,"height":32}]}],["$","a",null,{"href":"https://github.com/code-star","aria-label":"Github","children":["$","$L5",null,{"src":"/github_logo.svg","alt":"Codestar Github","width":32,"height":32}]}],["$","a",null,{"href":"https://medium.com/codestar-blog","aria-label":"Medium","children":["$","$L5",null,{"src":"/medium_logo.svg","alt":"Codestar Medium","width":32,"height":32}]}],["$","a",null,{"href":"https://www.linkedin.com/company/codestar-powered-by-sopra-steria/","aria-label":"Linkedin","children":["$","$L5",null,{"src":"/linkedin_logo.svg","alt":"Codestar LinkedIn","width":32,"height":32}]}],["$","a",null,{"href":"https://www.youtube.com/channel/UCqwHhJNEUe7D-HGsX4zvKzQ","aria-label":"Youtube","children":["$","$L5",null,{"src":"/youtube_logo.svg","alt":"Codestar Youtube","width":36,"height":32}]}],["$","a",null,{"href":"https://www.meetup.com/Code-Star-Night","aria-label":"Meetup.com","children":["$","$L5",null,{"src":"/meetup_logo.svg","alt":"Codestar Meetup","width":32,"height":32}]}]]}]]}]}]]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L6",null,["$","$L7",null,{"children":"$L8"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","sQhI6_IFprYhxvdq50FYH",{"children":[["$","$L9",null,{"children":"$La"}],["$","$Lb",null,{"children":"$Lc"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$d","$undefined"],"s":false,"S":true}
e:I[9214,["970","static/chunks/970-4a0f7daee52c7cff.js","904","static/chunks/app/articles/%5Bslug%5D/page-c42cdda36797932a.js"],"PreloadChunks"]
6:[["$","h1",null,{"children":"Sharing is Caring! Domain objects in BOTH Scala and R with GraalVM Polyglot bindings."}],["$","p",null,{"children":["Published at ","2019-05-01"," by ","Nathan Perdijk"]}],[["$","$Le",null,{"moduleIds":"$undefined"}],"$Lf"]]
10:T564,  // We need to initialise a GraalContext that will do the mediation between
  // the JVM languages and R
  val context: Context = Context.newBuilder("R").allowAllAccess(true).build()

  // Next, we need to create a Source which needs to know what language it features
  // and where to find the code.
  val sourceNoBindings: Source = 
    Source
      .newBuilder("R", Main.getClass.getResource("fun_NoBindingsWeatherForecasts.R"))
      .build()

  /*
   * We use the graal context to convert the source into a function.
   * Because R is dynamically typed, the compiler cannot help you here:
   * it trusts that you give it correct instructions!
   * This also means that you may ( => DEFINITELY) want to wrap any call
   * to this function in a Try to prevent explosions!
   *
   * We need to tell our compiler what kind of function this new Source represents.
   * In this case it is a function that takes one argument:
   *   - a path to another R function (which mocks the magic that R is good at)
   * And it returns... something rather complex: a Map of Strings, that refer to Lists
   * that contain... something we can't usefully Type because it will actually be
   * different things!
   */
  val rNoBindingsWeatherForecasts: String => util.Map[String, util.ArrayList[_]] =
    context.eval(sourceNoBindings).as(classOf[String => util.Map[String, util.ArrayList[_]]])
11:T65e,  private val path = Main.getClass.getResource("fun_MagicHappensHere.R").getPath
  Try(rNoBindingsWeatherForecasts(path)) match {
    case Failure(f) => print(f)
    case Success(s) =>
      // turning the Java Map into an immutable Scala Map, same for the Java List.
      val resultAsScala: Map[String, List[_]] =
        s.asScala.toMap.map(entry => entry._1 -> entry._2.asScala.toList)
      
      // We need to do a bunch of nasty casting, because the returntype is not uniform
      val humidities: List[Int] = resultAsScala("humidity").asInstanceOf[List[Int]]
      val temperatures: List[Int] = resultAsScala("temperature").asInstanceOf[List[Int]]
      val temperatureScale: List[String] = 
        resultAsScala("temperatureScale").asInstanceOf[List[String]]
      /*
       * We are omitting a bunch of things here:
       *   - there are more return values that need to be extracted from the map
       *     (which won't tell us if we're being exhaustive or not)
       *   - these return values need to be fit inside proper domain objects for further
       *     typesafe treatment, so we'll need to stitch elements from each list
       *     together...
       *
       * But already, we can see that this is:
       *   - very verbose
       *   - very error prone (it takes a lot of trial and error to get it right)
       *   - very brittle (it is very easy for a change somewhere else to break this
       *     parsing in half)
       *   - annoying to do!
       * If something is wrong (say, a column is missing), we get errors when parsing,
       * NOT where the actual mistake is made!
       */
    }
12:T449, /*
  * Our Domain object functions as a factory for our domain-related classes.
  * It has methods that create new instances of these classes, which can then safely be used from another Context.
  */
class Domain {
  def weatherForecastList(): WeatherForecastList = WeatherForecastList(List())
  def percentage(percent: Int): Percentage = Percentage(percent: Double)
  def chanceOfRain(chance: Percentage): ChanceOfRain = ChanceOfRain(chance: Percentage)
 
  def temperature(degrees: Int, temperatureScale: String): Temperature =
    Temperature(degrees: Int, temperatureScale: String)
 
  def windSpeed(scale: String, speed: Int): WindSpeed =
    WindSpeed(scale: String, speed: Int)
 
  def windForecast(windSpeed: WindSpeed, direction: String): WindForecast =
    WindForecast(windSpeed: WindSpeed, direction: String)
 
  def weatherForecast(
    humidity: Percentage,
    windForecast: WindForecast,
    sunshine: Percentage,
    temperature: Temperature,
    chanceOfRain: ChanceOfRain): WeatherForecast =
      WeatherForecast(humidity, windForecast, sunshine, temperature, chanceOfRain)
}
13:T7df,generateWeatherForecasts <- function(pathToMagicFile) {
  # We're bringing the function contained in the file at the given location into scope
  source(paste(pathToMagicFile))

  # This returns a dataframe, a way for R to store large quantities of data in an ordered
  # manner (kind of like a Database Table...)
  weatherForecast <- magicHappensHere()

  # We use the Scala Domain object provided through GraalVM bindings to get ourselves an
  # instance of the Scala wrapper containing a List of WeatherForecast
  weatherForecastList <- Domain$weatherForecastList()

  # We're looping over all the entries in the dataframe and getting the corresponding 
  # elements from the proper columns/rows
  for (count in seq(weatherForecast$humidity)) {
    # Here we use the provided add method to add a new WeatherForecast to the List.
    # Just like R, this Scala class returns a new, updated instance (rather than
    # updating the old), so we're reassigning the variable to this new instance.
    weatherForecastList <- weatherForecastList$add(
      # We are using Domain to construct properly Typed Scala instances of Domain classes.
      # Anything illegal (like putting a String in an Int, or Percentage) will cause an 
      # exception at the location of insertion! (Instead of after parsing!)
      # Yay for proper stacktraces!
      Domain$weatherForecast(
        Domain$percentage(weatherForecast$humidity[count]),
        Domain$windForecast(
          Domain$windSpeed(weatherForecast$windScale[count], weatherForecast$windSpeed[count]),
          weatherForecast$windDirection[count]
        ),
        Domain$percentage(weatherForecast$sunshine[count]),
        Domain$temperature(
          weatherForecast$temperature[count],
          weatherForecast$temperatureScale[count]
        ),
        Domain$chanceOfRain(Domain$percentage(weatherForecast$chanceOfRain[count]))
      )
    )
  }

  #like in Scala, the result of the last statement in an R function is its return.
  weatherForecastList
}
f:[["$","p",null,{"children":["$","strong",null,{"children":"In any domain that goes beyond a sample project, it becomes almost inevitable that you want to use objects that accurately represent that domain. GraalVM does an adequate job of converting datastructures from R to JVM languages and back by using sensible defaults, but what do you do when the sensible defaults are not sufficient? Given that GraalVM can perform translation between its multitude of supported languages, is it possible to define a “Domain” that can be accessed by all?"}]}],"\n",["$","p",null,{"children":["$","strong",null,{"children":"This is, of course, a rhetorical question and the answer is \"Yes\"."}]}],"\n",["$","img",null,{"src":"/articles/images/1LPCG2xlLiUdqcYJulzxvmw.png","alt":"","width":"800"}],"\n",["$","p",null,{"children":"In this article I'll demonstrate how to share domain objects between JVM languages and guest languages on the GraalVM platform. I'm using Scala domain objects (because Scala is awesome), but you could do the same with, for instance, Java or Kotlin."}],"\n",["$","p",null,{"children":["(If you’re new to GraalVM Polyglot abilities, consider also reading my previous article on the subject: ",["$","a",null,{"href":"https://medium.com/codestar-blog/in-search-of-the-holy-graalvm-putting-the-r-in-scala-or-java-or-b057494f77","children":"using GraalVM to execute R files from Scala"}],".)"]}],"\n",["$","h2",null,{"children":"The Problem"}],"\n",["$","p",null,{"children":"To demonstrate the problem we are trying to solve, we first need a pretend domain. Let’s do something with Weather Forecasts, because people always talk about the weather!"}],"\n",["$","p",null,{"children":["Creating weather forecasts is the kind of terribly complicated modelling business that could be built in R, but luckily we don’t actually ",["$","em",null,{"children":"need"}]," a working model for this article. So let’s just pretend we already have this awesome R functionality that creates weather forecasts, cleanly abstracted away in a separate file called ",["$","code",null,{"children":"fun_MagicHappensHere.R"}],":"]}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[fun_MagicHappensHere.R](https://gist.github.com/NRBPerdijk/4a115fe9e58ba6885f177bf3dd6b7f72#file-fun_MagicHappensHere-R)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"# Some very impressive R stuff happens here. \n# (Well, we're pretending it does, anyway! It's really just a mock...)\n# This function returns a data.frame containing a number of \n# weather forecasts that we need to bring back to the JVM\nmagicHappensHere <- function() {\n    # Omitting mocking code here\n    (...)\n    \n    # Like in Scala, the result of the last statement in an R function is its return.\n    weatherForecasts\n}\n"}]}],"\n",["$","p",null,{"children":["When brought into scope with R’s",["$","code",null,{"children":"source"}]," the above file will yield a ",["$","code",null,{"children":"magicHappensHere"}]," function that can be called and returns a ",["$","code",null,{"children":"data.frame"}]," with some weather forecast information. We can then return the result to Scala by simply making it the return of our R function:"]}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[fun_NoBindingsWeatherForecasts.R](https://gist.github.com/NRBPerdijk/01f617dfdcbed15713aec8b71c2758df#file-fun_NoBindingsWeatherForecasts-R)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"generateWeatherForecasts <- function(pathToMagicFile) {\n\n  # We're bringing the function contained in the file at the given location into scope\n  source(paste(pathToMagicFile))\n\n  # This returns a dataframe, a way for R to store large quantities of data\n  # in an ordered manner (kind of like a Database Table...)\n  weatherForecast <- magicHappensHere()\n\n  # Like in Scala, the result of the last statement in an R function is its return.\n  weatherForecast\n}\n"}]}],"\n",["$","p",null,{"children":"Wow, that doesn’t look too bad! This won’t get many complaints from the Data Scientist, I reckon."}],"\n",["$","blockquote",null,{"children":["\n",["$","p",null,{"children":"So, what’s wrong with this? What’s the problem?"}],"\n"]}],"\n",["$","p",null,{"children":["I’m glad you asked, ",["$","a",null,{"href":"https://www.dictionary.com/browse/interlocutor","children":"interlocutor"}],"! Let’s take a look on the Scala/JVM side of this equation, to see what the Data Engineer has to deal with:"]}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[Main.scala](https://gist.github.com/NRBPerdijk/178b2c01420db29de4863f4bf94e0178#file-Main-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"$10"}]}],"\n",["$","p",null,{"children":"Whoa… creating the Graal Context and Source is trivial, but look at the nasty type signature on that call to R! Let’s pick it apart for a bit:"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["A ",["$","code",null,{"children":"Map"}]," that contains ",["$","code",null,{"children":"List"}],"s of each ",["$","code",null,{"children":"data.frame"}]," row keyed by its name… That makes sense, well done Graal! It’s just too bad it’s Stringly typed, rather than actual methods on an actual class, so any typo will mess us up at runtime."]}],"\n",["$","li",null,{"children":["Unknown content type of the Lists?… That’s unfortunate, we know that some rows should only contain ",["$","code",null,{"children":"String"}],", while others contain ",["$","code",null,{"children":"Int"}]," but this information is lost in conversion… We have to do a bunch of casting!"]}],"\n",["$","li",null,{"children":["The returned Collections are Java? That’s just sad! The polyglot representation of collections doesn’t transfer to Scala, but Scala ",["$","code",null,{"children":"Map"}]," and ",["$","code",null,{"children":"List"}]," are much more powerful than their Java equivalent, so we’ll have to convert the Java equivalents!"]}],"\n",["$","li",null,{"children":["Every element of each ",["$","code",null,{"children":"List"}]," doesn’t actually belong to the rest of the ",["$","code",null,{"children":"List"}],", but instead should be combined with each corresponding position in every other ",["$","code",null,{"children":"List"}]," to actually make a ",["$","code",null,{"children":"WeatherReport"}],"… (The first entry of “humidities”, should be paired with the first entry of “temperatures” etc.)"]}],"\n"]}],"\n",["$","p",null,{"children":"Let’s see what this means when we try to use the output of this function:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[Main.scala](https://gist.github.com/NRBPerdijk/9e36ef4ba3fd89f633b49b55c2c9c745#file-Main-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"$11"}]}],"\n",["$","p",null,{"children":["I don’t know about you, but I’d feel quite uncomfortable at the thought of maintaining the code above. It’s verbose, error prone, brittle, annoying and it fails at the wrong spot if any mistakes are introduced (namely at the place of conversion, rather than the place of programming error). I wish the R function would just return a ",["$","code",null,{"children":"Set"}]," of ",["$","code",null,{"children":"WeatherForecast"}],"!"]}],"\n",["$","p",null,{"children":"Whoops, hold on… Wait a minute…"}],"\n",["$","p",null,{"children":["Why don’t we just ",["$","em",null,{"children":["$","strong",null,{"children":"make it do that?"}]}]]}],"\n",["$","h2",null,{"children":["$","strong",null,{"children":"The Solution: Bindings"}]}],"\n",["$","p",null,{"children":"GraalVM comes with an option that makes it possible to explicitly share instances of code across the language divide. It makes it possible to add symbols to bindings that are accessible to other languages. The Graal Context has two functions that can be used to do this in a very similar way:"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["$","a",null,{"href":"https://www.graalvm.org/sdk/javadoc/org/graalvm/polyglot/Context.html#getPolyglotBindings--","children":["$","code",null,{"children":"getPolyglotBindings()"}]}]}],"\n",["$","li",null,{"children":["$","a",null,{"href":"https://www.graalvm.org/sdk/javadoc/org/graalvm/polyglot/Context.html#getBindings-java.lang.String-","children":["$","code",null,{"children":"getBindings(“nameOfLanguage\")"}]}]}],"\n"]}],"\n",["$","p",null,{"children":["In this article I will be using ",["$","code",null,{"children":"getBindings"}],", because it doesn’t require an explicit import on the side of the using language and it allows you to limit which languages you are exposing each binding to. Using ",["$","code",null,{"children":"getPolyglotBindings()"}]," is almost identical from a coding perspective though, so pick the one you like best."]}],"\n",["$","h3",null,{"children":"Using Domain objects on both sides of the language divide"}],"\n",["$","p",null,{"children":"This is what our Domain object looks like:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[Domain.scala](https://gist.github.com/NRBPerdijk/4c64c4966621cbd6567b39e15208bc47#file-Domain-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"$12"}]}],"\n",["$","p",null,{"children":[["$","code",null,{"children":"Domain"}]," is basically a factory that can be used to spawn new instances of all the domain classes that we want to share. The class",["$","code",null,{"children":"Domain"}]," itself is immutable! (As it happens, the spawned instances are too.)"]}],"\n",["$","blockquote",null,{"children":["\n",["$","p",null,{"children":[["$","strong",null,{"children":"WARNING"}],": You probably don’t want to put a mutable object into bindings. If you do, this object can be mutated ",["$","strong",null,{"children":"from any language that can reach it"}],". Just as you don’t want multiple threads to tangle with the same mutable object, you don’t want multiple languages to access the same mutable state! (Really! Imagine having to debug race conditions across language boundaries...)"]}],"\n"]}],"\n",["$","p",null,{"children":["Any instance of the ",["$","code",null,{"children":"Domain"}]," class provides methods to spawn new instances of the following domain case classes:"]}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[WeatherForecast.scala](https://gist.github.com/NRBPerdijk/eae681fac5c1e060f48d5521c7743d01#file-WeatherForecast-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"case class WeatherForecast(\n  humidity: Percentage,\n  windForecast: WindForecast,\n  sunshine: Percentage,\n  temperature: Temperature,\n  chanceOfRain: ChanceOfRain\n)\ncase class Temperature(degrees: Int, temperatureScale: String)\ncase class Percentage(percent: Double)\ncase class WindForecast(windSpeed: WindSpeed, direction: String)\ncase class WindSpeed(scale: String, speed: Int)\ncase class ChanceOfRain(chance: Percentage)\ncase class WeatherForecastList(asScalaList: List[WeatherForecast]) {\n  def add(weatherForecast: WeatherForecast): WeatherForecastList =\n    this.copy(weatherForecast :: asScalaList)\n}\n"}]}],"\n",["$","p",null,{"children":["Let’s put an instance of our ",["$","code",null,{"children":"Domain"}]," class into the bindings for R, so it can be accessed from the R guest language context:"]}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[Main.scala](https://gist.github.com/NRBPerdijk/badcd84759c7bf7154c3303d56cf19c0#file-Main-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"/*\n   * Exposing bindings is an interesting way to share functionality between languages.\n   * This command makes an instance of the Domain class available under the \"Domain\"\n   * accessor.\n   */\n  context.getBindings(\"R\").putMember(\"Domain\", new Domain)\n  \n"}]}],"\n",["$","p",null,{"children":["Easy peasy. From R, the new object will simply be known as ",["$","code",null,{"children":"Domain"}]," and its methods will be accessible like this: ",["$","code",null,{"children":"Domain$methodName(arguments)"}]]}],"\n",["$","p",null,{"children":["We turn a new R file, that uses this binding, into our newest ",["$","code",null,{"children":"Source"}],":"]}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[Main.scala](https://gist.github.com/NRBPerdijk/72f9552fe0267d5fac9581d5b4e81470#file-Main-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"  // This source will use the provided Domain instance to create objects as they have been\n  // defined in the Scala domain.\n  val sourceWithBindings: Source = \n    Source\n      .newBuilder(\"R\", Main.getClass.getResource(\"fun_WithBindingsWeatherForecasts.R\"))\n      .build()\n"}]}],"\n",["$","p",null,{"children":"And then we define the function:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[Main.scala](https://gist.github.com/NRBPerdijk/c093d7d313727e2f527fc8891f569f59#file-Main-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"  // This function signature is a lot cleaner than the one that doesn't use bindings.\n  // It is also completely Scala, meaning we do not have to do ANY parsing.\n  val rMagicWithBindings: String => WeatherForecastList =\n    context.eval(sourceWithBindings).as(classOf[String => WeatherForecastList])\n"}]}],"\n",["$","p",null,{"children":["Now that this is our return type, all we need to do to work with the returned ",["$","code",null,{"children":"WeatherForecast"}],"s is this:"]}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[Main.scala](https://gist.github.com/NRBPerdijk/446b9d3ba6c1ee37ebac2b88ef8a719d#file-Main-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"// Remember to always put a call to R in a Try block, because\n// R often resorts to throwing RuntimeExceptions.\n  Try(rMagicWithBindings(path)) match {\n    case Failure(f) => print(f)\n    case Success(weatherForecastList) =>\n      // We get back a WeatherForecastList, which is a wrapper for List[WeatherForecast].\n      // Now we can work with the results WITHOUT any parsing:\n      // simply take out the List and do your operations (here we print them one by one).\n      weatherForecastList.asScalaList.foreach(forecast => println(forecast))\n  }\n"}]}],"\n",["$","p",null,{"children":"That is one very happy Data Engineer! (Don’t forget to compare with the incomplete parsing above.)"}],"\n",["$","p",null,{"children":"Now, let’s see the impact on the DataScientist side:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[fun_WithBindingsWeatherForecasts.R](https://gist.github.com/NRBPerdijk/da927c196ef81aece09b5561c0e8b6ba#file-fun_WithBindingsWeatherForecasts-R)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"$13"}]}],"\n",["$","p",null,{"children":"As we can see, the code has become more verbose (although it’s actually quite efficient still, if you take out all the clarifying comments I put in), but not quite as bad as in the previous solution:"}],"\n",["$","p",null,{"children":["In this R file, we now need to convert the ",["$","code",null,{"children":"data.frame"}]," to proper ",["$","code",null,{"children":"WeatherForecast"}]," instances to be added to the ",["$","code",null,{"children":"WeatherForecastList"}]," we also got from ",["$","code",null,{"children":"Domain"}],". But rather than doing a Parse & Pray, as we had to do with the no-bindings solution, we can now use proper constructors that will fail with intelligible errors if we make a mistake. (Sadly still only at runtime, because this is still R.) Cleanly taking values out of the ",["$","code",null,{"children":"data.frame"}]," is also better supported by its native language and we could add more convenience methods to more succinctly create the domain classes if we wanted to. If we have direct control over the function that creates the weather forecasts, we can even skip the ",["$","code",null,{"children":"data.frame"}]," altogether and exclusively use ",["$","code",null,{"children":"WeatherForecastList"}],", which eliminates the extra code seen above."]}],"\n",["$","p",null,{"children":["The biggest advantage, though, is that we now have a very clearly defined interface. Any user can open up the ",["$","code",null,{"children":"Domain.scala"}]," file to see what methods are available, what parameters they take and what things they return."]}],"\n",["$","h2",null,{"children":["$","strong",null,{"children":"Conclusion"}]}],"\n",["$","p",null,{"children":"Using Bindings to provide a clean shared domain between guest languages (like R or Python) and JVM languages (like Scala, Java or Kotlin) in GraalVM is pretty easy and gets rid of a lot of ugly and fault-sensitive parsing. It also provides a crucial stepping stone for further integration of functionalities across language boundaries."}],"\n",["$","p",null,{"children":[["$","strong",null,{"children":"PS"}],": I could have added a factory for each separate domain class to the bindings, instead of giving them a shared factory. This can make the code on the R side a little shorter, but creates a less clean interface (at least to my taste)."]}],"\n",["$","h2",null,{"children":["$","strong",null,{"children":"Sourcecode"}]}],"\n",["$","p",null,{"children":["I have reused the example project from my previous article on ",["$","a",null,{"href":"https://medium.com/codestar-blog/in-search-of-the-holy-graalvm-putting-the-r-in-scala-or-java-or-b057494f77","children":"using GraalVM to execute R files from Scala"}],") and branched it for this article. The source code can be found ",["$","a",null,{"href":"https://github.com/NRBPerdijk/example-graalvm-r-scala/tree/usingBindingsToShareDomain","children":"here"}],". The snippets above are taken from the linked project and altered to better fit the sizing of the article."]}]]
c:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Codestar"}],["$","meta","2",{"name":"description","content":"Codestar - a Sopra Steria team"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
8:null
