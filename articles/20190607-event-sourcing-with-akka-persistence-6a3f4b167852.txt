1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
4:I[8173,["970","static/chunks/970-4a0f7daee52c7cff.js","173","static/chunks/173-77a4cc13cb7e18d3.js","571","static/chunks/app/articles/%5Bslug%5D/layout-0f8ac0524a72511b.js"],""]
5:I[7970,["970","static/chunks/970-4a0f7daee52c7cff.js","904","static/chunks/app/articles/%5Bslug%5D/page-c42cdda36797932a.js"],"Image"]
7:I[6213,[],"OutletBoundary"]
9:I[6213,[],"MetadataBoundary"]
b:I[6213,[],"ViewportBoundary"]
d:I[4835,[],""]
:HL["/_next/static/media/4cf2300e9c8272f7-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/deecf931bfbdc38e.css","style"]
:HL["/_next/static/css/13422ae1d848e043.css","style"]
0:{"P":null,"b":"ygbqWoNid8Od9qRgeKZZp","p":"","c":["","articles","20190607-event-sourcing-with-akka-persistence-6a3f4b167852"],"i":false,"f":[[["",{"children":["articles",{"children":[["slug","20190607-event-sourcing-with-akka-persistence-6a3f4b167852","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/deecf931bfbdc38e.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_188709 __variable_9a8899","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["articles",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","articles","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","20190607-event-sourcing-with-akka-persistence-6a3f4b167852","d"],["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/13422ae1d848e043.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],[null,["$","nav",null,{"className":"TopBar_top-bar__RDkoF","children":["$","div",null,{"children":[["$","$L4",null,{"href":"/","children":["$","$L5",null,{"src":"/codestar_logo_cream-red.svg","alt":"Codestar Logo","width":150,"height":40}]}],["$","ul",null,{"children":["$","li",null,{"children":["$","a",null,{"href":"https://www.linkedin.com/company/codestar-powered-by-sopra-steria/","children":"Contact"}]}]}]]}]}],["$","div",null,{"className":"layout_content__K15KO","children":["$","main",null,{"className":"layout_main__Afkre","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","articles","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]}],["$","footer",null,{"className":"Footer_footer__OYoYH","children":["$","div",null,{"children":[["$","ul",null,{"className":"contact-info","children":[["$","li",null,{"children":["$","a",null,{"href":"mailto:codestar@ordina.nl","children":"codestar.nl@soprasteria.com"}]}],["$","li",null,{"children":["$","a",null,{"href":"tel:+31306637000","children":"+31 30 6637000"}]}],["$","li",null,{"children":["$","a",null,{"href":"https://maps.google.com/maps?ll=52.057652,5.111462&z=16&t=m&hl=en-GB&gl=NL&mapclient=embed&cid=15918536717636328792","target":"_blank","rel":"noopener noreferrer","children":"Ringwade 1, 3439 LM Nieuwegein"}]}]]}],["$","p",null,{"className":"social-links","children":[["$","a",null,{"href":"https://mastodon.social/@codestar","aria-label":"Mastodon","rel":"me","children":["$","$L5",null,{"src":"/mastodon_logo.svg","alt":"Codestar Mastodon","width":32,"height":32}]}],["$","a",null,{"href":"https://github.com/code-star","aria-label":"Github","children":["$","$L5",null,{"src":"/github_logo.svg","alt":"Codestar Github","width":32,"height":32}]}],["$","a",null,{"href":"https://medium.com/codestar-blog","aria-label":"Medium","children":["$","$L5",null,{"src":"/medium_logo.svg","alt":"Codestar Medium","width":32,"height":32}]}],["$","a",null,{"href":"https://www.linkedin.com/company/codestar-powered-by-sopra-steria/","aria-label":"Linkedin","children":["$","$L5",null,{"src":"/linkedin_logo.svg","alt":"Codestar LinkedIn","width":32,"height":32}]}],["$","a",null,{"href":"https://www.youtube.com/channel/UCqwHhJNEUe7D-HGsX4zvKzQ","aria-label":"Youtube","children":["$","$L5",null,{"src":"/youtube_logo.svg","alt":"Codestar Youtube","width":36,"height":32}]}],["$","a",null,{"href":"https://www.meetup.com/Code-Star-Night","aria-label":"Meetup.com","children":["$","$L5",null,{"src":"/meetup_logo.svg","alt":"Codestar Meetup","width":32,"height":32}]}]]}]]}]}]]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L6",null,["$","$L7",null,{"children":"$L8"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","1mr7PaoT3uOXLBxWUCFtb",{"children":[["$","$L9",null,{"children":"$La"}],["$","$Lb",null,{"children":"$Lc"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$d","$undefined"],"s":false,"S":true}
e:I[9214,["970","static/chunks/970-4a0f7daee52c7cff.js","904","static/chunks/app/articles/%5Bslug%5D/page-c42cdda36797932a.js"],"PreloadChunks"]
6:[["$","h1",null,{"children":"Event sourcing with Akka Persistence"}],["$","p",null,{"children":["Published at ","2019-06-07"," by ","Nick ten Veen"]}],[["$","$Le",null,{"moduleIds":"$undefined"}],"$Lf"]]
f:[["$","h3",null,{"children":"Asynchronous pains"}],"\n",["$","p",null,{"children":["In one of our projects at the Port of Rotterdam we do a lot of stream processing where we require intermediate state. We are using Event Sourcing with ",["$","a",null,{"href":"https://doc.akka.io/docs/akka/current/typed/persistence.html","children":"Akka Persistence"}],". It allows us to create robust stateful streaming applications that can maintain state between application restarts. We were struggling a bit writing our command handlers since we do a bunch of asynchronous operations. Akka Persistence does not allow you to handle command asynchronously which means you need to deal with this yourself. Let us explore the problem in a simplified event sourcing application."]}],"\n",["$","h3",null,{"children":"Event Sourcing"}],"\n",["$","p",null,{"children":"Let us create a simple implementation of an event sourcing system. A simple calculator that can add and subtract values. First we define our state, which is simply an integer value:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block1.scala](https://gist.github.com/besuikerd/f860cbd65e5c4c0cc1f8f22ecfda0b94#file-block1-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"case class State(n: Int)\n"}]}],"\n",["$","p",null,{"children":"The state can only be modified by firing events. Let us create two possible operations, adding and subtracting from the state:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block2.scala](https://gist.github.com/besuikerd/08af6b2f0526d6edeae5a7288b6f2f2b#file-block2-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"sealed trait Event\ncase class Added(n: Int) extends Event\ncase class Subtracted(n: Int) extends Event\n"}]}],"\n",["$","p",null,{"children":"Now that we have a definition for our state and possible events, we can write a handler that will process these events:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block3.scala](https://gist.github.com/besuikerd/b9265ac0a285d7e096ce27332cbdf18e#file-block3-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"type EventHandler = (State, Event) => State\n\nval eventHandler: EventHandler = \n  (state, event) =>\n     event match {\n       case Added(n)      => state.copy(n = state.n + n)\n       case Subtracted(n) => state.copy(n = state.n - n)\n   }\n"}]}],"\n",["$","p",null,{"children":"We can test the event handler to verify that the events are processed correctly:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block4.scala](https://gist.github.com/besuikerd/a63482d631107621c5d3b4e3142dff9b#file-block4-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"eventHandler(State(2), Added(2)) shouldBe State(4)\neventHandler(State(42), Subtracted(21)) shouldBe State(21)\n"}]}],"\n",["$","h3",null,{"children":"Commands"}],"\n",["$","p",null,{"children":"In event sourcing, events are immutable facts that happened. These events should be handled deterministically without any side effect. However, sometimes we need to perform side effects. For example when we need to query a database to check if an operation is allowed. We can use the command abstraction for this purpose. A command is a request to do something. Requests can be accepted or denied, or even transformed. They are also allowed to perform side effects. We can define commands for addition and subtraction:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block5.scala](https://gist.github.com/besuikerd/7ad7221547e7cbc05b73a7a333bf737c#file-block5-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"sealed trait Command\n\ncase class Add(n: Int) extends Command\ncase class Sub(n: Int) extends Command\n"}]}],"\n",["$","p",null,{"children":"A command handler can process these commands and decide to fire zero or more events:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block6.scala](https://gist.github.com/besuikerd/161e166621d79da4cc2769a09b2e5aa6#file-block6-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"type CommandHandler = (State, Command) => Seq[Event]\n\nval commandHandler: CommandHandler = \n  (state, command) => command match {\n    case Add(n) => Seq(Added(n))\n    case Sub(n) => Seq(Subtracted(n))\n  }\n"}]}],"\n",["$","p",null,{"children":"We can test the command handler to verify it will fire events accordingly:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block7.scala](https://gist.github.com/besuikerd/0f08b31ca39ca0bac9a16dfdd6c0e993#file-block7-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"commandHandler(State(0), Add(2)) shouldBe Seq(Added(2))\ncommandHandler(State(0), Subtract(42)) shouldBe Seq(Subtracted(42))\n"}]}],"\n",["$","p",null,{"children":"The command handler and event handler can be folded together to calculate the state for a given list of commands:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block8.scala](https://gist.github.com/besuikerd/c115e2df5c28c50797abd0fa951ccbe5#file-block8-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"def combined(commands: Seq[Command]): State =\n  commands.foldLeft(State(0)) {\n      case (state, command) =>\n        val events = commandHandler(state, command)\n        events.foldLeft(state)(eventHandler)\n    }\n"}]}],"\n",["$","p",null,{"children":"This all works fine, but if we want to recover the state during a crash or restart, we also need to store the events that we persist. We need a function that accumulates the events while calculating the state:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block9.scala](https://gist.github.com/besuikerd/5a9e4ca0ef7e199caddb3b16c105aef3#file-block9-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"def combinedWithEvents(commands: Seq[Command]): (State, Seq[Event]) =\n    commands.foldLeft((State(0), Seq.empty[Event])) {\n      case ((state, accumulatedEvents), command) =>\n        val events    = commandHandler(state, command)\n        val nextState = events.foldLeft(state)(eventHandler)\n        (nextState, accumulatedEvents ++ events)\n    }\n"}]}],"\n",["$","p",null,{"children":["We can keep the accumulated state in memory during processing and at the same time persist the generated events somewhere. On restarts we can replay these events with the ",["$","code",null,{"children":"eventHandler"}]," to restore our state."]}],"\n",["$","h3",null,{"children":"Akka Persistence"}],"\n",["$","p",null,{"children":["This pattern is encoded in Akka Persistence and allows us to have actors with state that can be recovered after crashes and restarts. The command handler is a little bit different. Instead of returning a list of events that happened, you can specify an ",["$","code",null,{"children":"Effect"}],". These effects are simply an encoding of possible actions a persistent actor can do after receiving a command:"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Persist an event"}],"\n",["$","li",null,{"children":"Stop the actor"}],"\n",["$","li",null,{"children":"Stash the command"}],"\n",["$","li",null,{"children":"Do nothing"}],"\n"]}],"\n",["$","p",null,{"children":"These effects can be composed together to (for example) persist multiple events. In our example we can write a simple command handler:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block10.scala](https://gist.github.com/besuikerd/94f2c3c255bdff421c5a3de1ad0ae6a9#file-block10-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"type CommandHandler[Command, Event, State] = (State, Command) â‡’ Effect[Event, State]\n\nval commandHandler: CommandHandler[Command, Event, State] = (state, command) => \n    command match {\n        case Add(n) => Effect.persist(Added(n))\n        case Sub(n) => Effect.persist(Subtracted(n))\n      }\n"}]}],"\n",["$","h3",null,{"children":"Asynchronous command handling"}],"\n",["$","p",null,{"children":["One issue about the ",["$","code",null,{"children":"commandHandler"}]," is that it is synchronous. ",["$","a",null,{"href":"https://github.com/akka/akka/issues/25650","children":"There are currently no plans for aynchronous command handlers in akka"}]," persistence. If you want to do some asynchronous processing before deciding to persist an event, you need to introduce extra commands. For example, lets say we want to have a check if a specific addition or subtraction is allowed before we emit an event. We really need to do this asynchronously for some reason, so lets create a definition of our permission check:"]}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block11.scala](https://gist.github.com/besuikerd/582ff0a0dafe23067676abe807466311#file-block11-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"type CheckPermission = Int => Future[Boolean]\n\nval trivialCheck: CheckPermission = _ => Future.successful(true)\n"}]}],"\n",["$","p",null,{"children":"To be able to add this to our command handler, we need an extra command that is fired after validation. We also group our previous commands into a subtype so it can be a parameter of our new command:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block12.scala](https://gist.github.com/besuikerd/9169c542dd68d396b4b30189f260ffc1#file-block12-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"sealed trait Command\n\nsealed trait AlgebraicCommand extends Command { def n: Int }\ncase class Add(n: Int)        extends AlgebraicCommand\ncase class Sub(n: Int)        extends AlgebraicCommand\n\ncase class OperationAllowed(algebraicCommand: AlgebraicCommand) extends Command\n"}]}],"\n",["$","p",null,{"children":"With this definition we can rewrite our event handler to take this check into account:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block13.scala](https://gist.github.com/besuikerd/fb292d22d42a9a767bb2296da0562a2e#file-block13-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"def commandHandler(self: ActorRef[Command], checkPermission: CheckPermission): CommandHandler[Command, Event, State] =\n  (state, command) =>\n    command match {\n      case algebraicCommand: AlgebraicCommand =>\n        checkPermission(algebraicCommand.n).map {\n          case true =>\n            ctx.self ! OperationAllowed(op)\n          case _ => ()\n        }\n        Effect.none\n      case OperationAllowed(algebraicCommand) =>\n        algebraicCommand match {\n          case Add(n) => Effect.persist(Added(n))\n          case Sub(n) => Effect.persist(Subtracted(n))\n        }\n  }\n"}]}],"\n",["$","p",null,{"children":"This does work, however we lost a property that might be important to us. The order in which the algebraic commands are processed is lost due to the asynchronous boundary. Say our check is really slow for some specific elements. Other elements that arrived later might have been processed already and arrive out of order:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block14.scala](https://gist.github.com/besuikerd/9c4fe71b95328fc79537ff311f8ac986#file-block14-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"val slowCheck = (n: Int) =>\n      Future {\n        if (n == 3) {\n          Thread.sleep(3000)\n        }\n        true\n    }\n"}]}],"\n",["$","p",null,{"children":"If we would process the following commands in order, the outcome might have a different order:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block15.scala](https://gist.github.com/besuikerd/d474236e670ad484003575cc6b170d5a#file-block15-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"val commands = Seq(Add(2), Add(3), Sub(2))\n\nval events = processCommands(commands)\n\nevents shouldBe (Added(2), Subtracted(2), Added(3)) //They arrived in the wrong order\n"}]}],"\n",["$","p",null,{"children":"You could fix this by storing inflight messages in some (non-persistent) state, or by using the ask pattern and waiting for replies before sending each command. Currently (as far as I am aware) you are unable to store volatile state in a persistent actor. This means that if you want to store messages that are in flight, you need to use persistence for this. We can extend the state to store this along with a persistent event to signal inflight messages:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block16.scala](https://gist.github.com/besuikerd/171295d8524864177e7a8604f129d531#file-block16-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"case class State(n: Int, inFlight: Option[AlgebraicCommand])\n\ncase class Inflight(command: AlgebraicCommand) extends Event\n"}]}],"\n",["$","p",null,{"children":["Previously we only fired a command if an operation is allowed, but since we also need to unstash if an operation is not allowed, we always need to fire a command for a result. So we need to modify our ",["$","code",null,{"children":"OperationAllowed"}]," command:"]}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block17.scala](https://gist.github.com/besuikerd/526911697c11ec573958e92287503493#file-block17-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"case class CheckPermissionResult(\n  algebraicCommand: AlgebraicCommand,\n  allowed: Boolean\n) extends Command\n"}]}],"\n",["$","p",null,{"children":"Our event handler is now responsible for handling this extra event and cleaning up after a command has been successfully processed:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[block18.scala](https://gist.github.com/besuikerd/060de6dd2909eaacf1a5b6a221b080fa#file-block18-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"val eventHandler: EventHandler[State, Event] = (state, event) =>\n    event match {\n      case Added(n)          => state.copy(n = state.n + n, inFlight = None)\n      case Subtracted(n)     => state.copy(n = state.n - n, inFlight = None)\n      case Inflight(command) => state.copy(inFlight = Some(command))\n  }\n"}]}],"\n",["$","p",null,{"children":"Finally we need to rewrite our command handler to stash incoming commands as long as there is still a message in flight. After a command is successfully processed, we need to unstash to continue processing potentially stashed commands:"}],"\n",["$","p",null,{"children":["$","code",null,{"children":"[stashing-commandhandler.scala](https://gist.github.com/besuikerd/ff5ae12ad86652802ce1b4747c75f27b#file-stashing-commandhandler-scala)"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"def commandHandler: CommandHandler[Command, Event, State] =\n        (state, command) =>\n          command match {\n            case algebraicCommand: AlgebraicCommand =>\n              state.inFlight match {\n                case Some(inFlight) => Effect.stash()\n                case None =>\n                  Effect.persist[Event, State](Inflight(algebraicCommand)) thenRun { _ =>\n                    checkPermission(algebraicCommand.n).map { allowed =>\n                      ctx.self ! CheckPermissionResult(algebraicCommand, allowed)\n                    }\n                  }\n              }\n            case CheckPermissionResult(algebraicCommand, allowed) =>\n              val effect: EffectBuilder[Event, State] =\n                if (allowed) {\n                  algebraicCommand match {\n                    case Add(n) => Effect.persist(Added(n))\n                    case Sub(n) => Effect.persist(Subtracted(n))\n                  }\n                } else Effect.none\n              effect.thenUnstashAll()\n        }\n"}]}],"\n",["$","p",null,{"children":["After all this there are still a few concerns with this implementation. What if ",["$","code",null,{"children":"checkPermission"}]," fails? We would need to extend the example to deal with failing futures as well. Moreover, we persist the state of inflight messages so it survives restarts. However after a restart this message is not in flight and we might wait for eternity for it to resolve. This example illustrates that you can handle commands asynchronously, but in order to ensure messages are processed in the correct order, we needed to add error-prone synchronisation code."]}],"\n",["$","h3",null,{"children":"Conclusion"}],"\n",["$","p",null,{"children":"You can do asynchronous command handling with Akka Persistence. It does however require you to write some error-prone boilerplate code. Can we do better? Are persistent actors the correct approach for this problem? Maybe we can express the problem in a different paradigm where we still have the nice property of state recovery, while also allowing us to handle commands asynchronously. Maybe we could use stream processing to have a cleaner solution to our problem. But that is for another blog post."}]]
c:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
a:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Codestar"}],["$","meta","2",{"name":"description","content":"Codestar - a Sopra Steria team"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
8:null
